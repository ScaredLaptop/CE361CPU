$date
	Sun Nov  5 21:03:25 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb $end
$scope module CPU $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 7 # opcode [6:0] $end
$var wire 1 $ halt $end
$var wire 7 % funct7 [6:0] $end
$var wire 3 & funct3 [2:0] $end
$var wire 2 ' WBSel [1:0] $end
$var wire 5 ( Rsrc2 [4:0] $end
$var wire 5 ) Rsrc1 [4:0] $end
$var wire 5 * Rdst [4:0] $end
$var wire 32 + Rdata2 [31:0] $end
$var wire 32 , Rdata1 [31:0] $end
$var wire 1 - RWrEn $end
$var wire 32 . RWrData [31:0] $end
$var wire 1 / PCSel $end
$var wire 32 0 PC [31:0] $end
$var wire 32 1 NPC [31:0] $end
$var wire 2 2 MemSize [1:0] $end
$var wire 1 3 MemRW $end
$var wire 32 4 LoadExtended [31:0] $end
$var wire 32 5 InstWord [31:0] $end
$var wire 3 6 ImmSel [2:0] $end
$var wire 32 7 Imm [31:0] $end
$var wire 32 8 DataWord [31:0] $end
$var wire 1 9 BSel $end
$var wire 1 : BR $end
$var wire 1 ; ASel $end
$var wire 32 < ALU_B [31:0] $end
$var wire 32 = ALU_A [31:0] $end
$var wire 32 > ALUOutput [31:0] $end
$scope module BC $end
$var wire 3 ? funct3 [2:0] $end
$var wire 32 @ Rdata2 [31:0] $end
$var wire 32 A Rdata1 [31:0] $end
$var reg 1 : BR $end
$upscope $end
$scope module DMEM $end
$var wire 32 B AddrH [31:0] $end
$var wire 32 C AddrW [31:0] $end
$var wire 1 ! CLK $end
$var wire 1 3 WEN $end
$var wire 2 D Size [1:0] $end
$var wire 32 E DataIn [31:0] $end
$var wire 32 F Addr [31:0] $end
$var reg 32 G DataOut [31:0] $end
$upscope $end
$scope module EU $end
$var wire 7 H auxFunc [6:0] $end
$var wire 3 I func [2:0] $end
$var wire 32 J opA [31:0] $end
$var wire 32 K opB [31:0] $end
$var wire 7 L opcode [6:0] $end
$var wire 32 M s_opA [31:0] $end
$var wire 32 N s_opB [31:0] $end
$var reg 32 O out [31:0] $end
$upscope $end
$scope module IG $end
$var wire 32 P InstWord [31:0] $end
$var wire 3 Q ImmSel [2:0] $end
$var reg 32 R Imm [31:0] $end
$upscope $end
$scope module IMEM $end
$var wire 32 S AddrW [31:0] $end
$var wire 1 ! CLK $end
$var wire 2 T Size [1:0] $end
$var wire 32 U Addr [31:0] $end
$var reg 32 V DataOut [31:0] $end
$upscope $end
$scope module OD $end
$var wire 1 : BR $end
$var wire 3 W funct3 [2:0] $end
$var wire 7 X funct7 [6:0] $end
$var wire 7 Y op [6:0] $end
$var reg 1 ; ASel $end
$var reg 1 9 BSel $end
$var reg 3 Z ImmSel [2:0] $end
$var reg 1 3 MemRW $end
$var reg 1 / PCSel $end
$var reg 1 - RWrEn $end
$var reg 2 [ WBSel [1:0] $end
$var reg 1 $ halt $end
$upscope $end
$scope module PCU $end
$var wire 1 / PCSel $end
$var wire 32 \ PC_Jump [31:0] $end
$var wire 32 ] PC [31:0] $end
$var reg 32 ^ NPC [31:0] $end
$upscope $end
$scope module PC_REG $end
$var wire 1 ! CLK $end
$var wire 32 _ Din [31:0] $end
$var wire 1 " RST $end
$var wire 1 ` WEN $end
$var reg 32 a Qout [31:0] $end
$upscope $end
$scope module RF $end
$var wire 5 b AddrA [4:0] $end
$var wire 5 c AddrB [4:0] $end
$var wire 5 d AddrW [4:0] $end
$var wire 1 ! CLK $end
$var wire 32 e DataInW [31:0] $end
$var wire 1 - WenW $end
$var reg 32 f DataOutA [31:0] $end
$var reg 32 g DataOutB [31:0] $end
$upscope $end
$scope module SM $end
$var wire 32 h DataWord [31:0] $end
$var wire 3 i funct3 [2:0] $end
$var reg 32 j LoadExtended [31:0] $end
$var reg 2 k MemSize [1:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#35
$dumpvars
b0 k
b10011 j
b0 i
b10011000100110001001100010011 h
b0 g
b0 f
b0x00xx e
b0 d
b0 c
b0 b
b1100 a
0`
b10000 _
b10000 ^
b1100 ]
b0 \
bx [
b100 Z
b0 Y
b0 X
b0 W
b0 V
b1100 U
b10 T
b1100 S
b0 R
b100 Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
b10011000100110001001100010011 G
b0 F
b0 E
b0 D
b0 C
b0 B
b0 A
b0 @
b0 ?
b0 >
b0 =
b0 <
0;
1:
19
b10011000100110001001100010011 8
b0 7
b100 6
b0 5
b10011 4
03
b0 2
b10000 1
b1100 0
0/
b0x00xx .
1-
b0 ,
b0 +
b0 *
b0 )
b0 (
bx '
b0 &
b0 %
1$
b0 #
1"
1!
$end
